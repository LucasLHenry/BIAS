# BIAS
### Max for Live Instrument based on the Noise Engineering Basimilus Iteritas Alter

This is a simple Max Patch created for my Music 207 final project at the university of Victoria. As noted above, it is based on the Basimilus Iteritas Alter by Noise Engineering, a universal drum synthesizer created in the Eurorack modular format. This project is called BIAS, which stands for Basimilus Iteritas Alter Simplex. The addition of the word Simplex is both to follow the naming convention that Noise Engineering uses of Latin words, and also to indicate that this is a much less feature-rich synthesizer than the real BIA.

## OVERVIEW
BIAS contains 5 oscillators, all at harmonically related frequencies. These oscillators are controlled by the **OSCILLATOR** section, which includes volume mixing for the sine (**SINE**), triangle (**TRI**), and pulse (**PULSE**) wave components of the sound. It also includes a pulse width modulation knob (**WIDTH**) for the pulse wave, which goes from 1% to 99%.

The **HARMO** knob controls the mixing of the 5 oscillators. At 0 it contains only the first harmonic, or the fundamental. As the knob is turned clockwise, the harmonics are successively mixed in so that at 3 it contains the lowest 3 oscillators, and at 5 it contains all 5 oscillators. This successive mixing is achieved using the _expr_ object in Max, which is written as a shifted sigmoid function.

The **SPREAD** knob controls the harmonic relationship of the 5 oscillators. At the default value of 100%, the frequencies of the 5 harmonics are integer multiples of the fundamental, following the harmonic series. As the knob is turned up, the harmonics move further apart, ending at 200% by being seperated by the prime series (1, 3, 5, 7, 11). It should be noted that the fact that 2 is prime was ommited here, because if it were included then the second harmonic (2 times the frequency of the fundamental) would not change in frequency when the **SPREAD** knob was turned, which isn't very musically interesting.

The amplitude of BIAS is controlled by a simple ADSR envelope (**ENVELOPE**). This functions exactly like all other ADSR envelopes, and has the included M4L feature of having variable slope for the Attack, Decay, and Release stages. The **FOLD** slider controls the threshold for a simple bipolar wavefolder. This was a feature of the BIA as well, and can add a lot of character to the sound. It should be noted that the wavefolder is placed after the ADSR envelope in the signal path, and because the wavefolder is a non-linear (amplitude-dependant), the character of the sound will change with amplitude. This adds movement to the sound and is very powerful. This section is the most likely to be expanded upon in future, as it is currently implemented only using the M4L _pong~_ object.

## DESIGN NOTES

Initally there were issues with aliasing, because many M4L objects that create signals are not antialiased by default. This is especially prevelant for the _triangle~_ object, which is a trangle/ramp/sawtooth wavetable oscillator. This is not aliased, and immediately caused issues. For the sake of ease of developement, the sawtooth wave was scrapped and the _tri~_, _rect~_, and _cycle~_ objects were used instead. _tri~_ and _rect~_ are internally antialiased so there's no issue there, and _cycle~_ contains no harmonics beyond the fundamental so unless someone's trying to play a note above 20kHz there won't be any aliasing from that.

Another issue encountered was the fact that Max tends to not like updating calculations, so many times new settings were not changed when they shoud have been. This was mainly fixed by using a lot of _bang_ objects, but there is definitely room for optimization there. This issue was especially prevelant for _expr_ objects that relied on multiple values, so if one value was changed that wasn't the primary inlet, the calculation would not be redone.

To avoid issues with volume changing when mixing different waveforms, the _normalize~_ object was used. This object scales signals to be between -1. and 1., based on the highest amplitude is has recieved yet. One of these objects was placed at the end of chain for each of the oscillators' mixers, and another one was used after they were mixed. There was an issue that at extreme settings of FOLD, the amplitude decreased dramatically. I attempted to fix this using a _normalize~_ object, but I found that it nullified the effect of the sustain stage of the ADSR. This is because it would try to increase the amplitude of that stage to full to normalize it when I want to retain this difference in volume. This issue has yet to be solved.
